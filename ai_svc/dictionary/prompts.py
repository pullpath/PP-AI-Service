"""
Dictionary service prompts for specialized agents
"""
from typing import List


def get_etymology_prompt(word: str) -> str:
    """Generate prompt for etymology information"""
    return f"""Provide etymology for "{word}":

1. Etymology: Origin, historical development, meaning evolution (2-3 sentences)
2. Root Analysis: Break down roots, prefixes, suffixes with meanings

Return valid JSON matching EtymologyInfo schema."""


def get_word_family_prompt(word: str) -> str:
    """Generate prompt for word family information"""
    return f"""You are a linguistic analyst specializing in word relationships.

Provide the word family for "{word}".

List 5-15 key words derived from the same root or sharing the same base.
Include:
- Direct derivatives (e.g., "happy" â†’ "happiness", "unhappy")
- Related terms from same linguistic root
- Words in the same semantic field

IMPORTANT: Return ONLY a valid JSON object with this exact structure:
{{
    "word_family": ["word1", "word2", "word3"]
}}

Each word must be a simple string. Do not include explanations, examples, or additional formatting.
Ensure all strings are properly closed with quotes."""


def get_usage_context_prompt(word: str) -> str:
    """Generate prompt for usage context information"""
    return f"""Provide usage context for "{word}":

1. Modern Relevance: Current trends (e.g., "rising in tech", "outdated")
2. Common Confusions: Words confused with this (with brief differences)
3. Regional Variations: UK/US/AU differences

Return valid JSON matching UsageContextInfo schema."""


def get_cultural_notes_prompt(word: str) -> str:
    """Generate prompt for cultural and linguistic notes"""
    return f"""Provide cultural notes for "{word}":

Include cultural associations, historical significance, or sociolinguistic observations (2-3 sentences).

Return valid JSON matching CulturalNotesInfo schema."""


def get_frequency_prompt(word: str) -> str:
    """Generate prompt for frequency estimation"""
    return f"""Estimate frequency of "{word}" in modern English.

Choose: very_common (top 1000), common (top 5000), uncommon (top 20000), rare, or very_rare.

Return valid JSON matching FrequencyInfo schema."""


# 2-Agent Parallel Execution Prompts for DetailedWordSense
# These prompts split detailed sense generation into 2 concurrent tasks for optimal performance
def get_sense_core_metadata_prompt(word: str, sense_index: int, basic_definition: str) -> str:
    """Generate prompt for core metadata (Agent 1) - parallel execution
    
    Note: API always provides definition (not generated by AI)
    """
    return f"""You are a linguistic expert analyzing word meanings.

Analyze sense #{sense_index + 1} of "{word}": "{basic_definition}"

The definition is already provided by the API. Provide ONLY metadata analysis:

1. **part_of_speech**: e.g., noun, verb, phrasal verb, adjective, idiom, etc.
2. **usage_register**: List of appropriate contexts (formal, informal, colloquial, slang, archaic, literary, professional, academic, neutral)
3. **domain**: Specific fields of use (e.g., biology, law, gaming, business) - can be empty list
4. **tone**: Primary connotation (positive, negative, neutral, humorous, derogatory, pejorative, approving)

Focus on accuracy and clarity for language learners.

Output must be valid JSON matching the SenseCoreMetadata schema."""


def get_sense_usage_examples_prompt(word: str, sense_index: int, basic_definition: str,
                                   api_examples=None, examples_needed: int = 2, 
                                   collocations_needed: int = 3) -> str:
    """Generate prompt for examples and collocations (Agent 2) - parallel execution
    
    Dynamic counts based on API data availability:
    - examples_needed: Number of additional examples to generate (0-2)
    - collocations_needed: Number of collocations to generate (0-3)
    """
    api_examples = api_examples or []
    
    # Build dynamic context
    if api_examples:
        examples_context = f"\n\nAPI already provided {len(api_examples)} example(s): {api_examples}"
    else:
        examples_context = ""
    
    # Build dynamic instructions
    if examples_needed > 0:
        examples_instruction = f"1. **examples**: Exactly {examples_needed} additional example sentence(s) showing this sense in natural context"
    else:
        examples_instruction = "1. **examples**: Empty list (API already provided sufficient examples)"
    
    if collocations_needed > 0:
        collocations_instruction = f"2. **collocations**: Exactly {collocations_needed} most frequent word partner(s) (e.g., \"strong evidence\", \"gather evidence\")"
    else:
        collocations_instruction = "2. **collocations**: Empty list (not needed)"
    
    return f"""You are a linguistic expert specializing in language usage and examples.

Analyze sense #{sense_index + 1} of "{word}": "{basic_definition}"{examples_context}

Provide:
{examples_instruction}
{collocations_instruction}

Focus on practical, real-world usage for language learners.

Output must be valid JSON matching the SenseUsageExamples schema."""


def get_sense_related_words_prompt(word: str, sense_index: int, basic_definition: str,
                                   api_synonyms=None, api_antonyms=None,
                                   synonyms_needed: int = 3, antonyms_needed: int = 3,
                                   phrases_needed: int = 3) -> str:
    """Generate prompt for related words and phrases (Agent 3) - parallel execution
    
    Dynamic counts based on API data availability:
    - synonyms_needed: Number of additional synonyms to generate (0-3)
    - antonyms_needed: Number of additional antonyms to generate (0-3)
    - phrases_needed: Number of phrases to generate (0-3)
    """
    api_synonyms = api_synonyms or []
    api_antonyms = api_antonyms or []
    
    if api_synonyms:
        synonyms_context = f"\n\nAPI already provided {len(api_synonyms)} synonym(s): {api_synonyms}"
    else:
        synonyms_context = ""
    
    if api_antonyms:
        antonyms_context = f"\n\nAPI already provided {len(api_antonyms)} antonym(s): {api_antonyms}"
    else:
        antonyms_context = ""
    
    if synonyms_needed > 0:
        synonyms_instruction = f"1. **synonyms**: Exactly {synonyms_needed} additional most common synonym(s) for this specific sense"
    else:
        synonyms_instruction = "1. **synonyms**: Empty list (API already provided sufficient synonyms)"
    
    if antonyms_needed > 0:
        antonyms_instruction = f"2. **antonyms**: Exactly {antonyms_needed} additional most common antonym(s) for this specific sense (can be empty if none exist)"
    else:
        antonyms_instruction = "2. **antonyms**: Empty list (API already provided sufficient antonyms)"
    
    if phrases_needed > 0:
        phrases_instruction = f"3. **word_specific_phrases**: Exactly {phrases_needed} most common fixed expression(s), phrasal verb(s), or idiom(s) built around this sense (e.g., \"run up a bill\", \"in the long run\")"
    else:
        phrases_instruction = "3. **word_specific_phrases**: Empty list (not needed)"
    
    return f"""You are a linguistic expert specializing in word relationships.

Analyze sense #{sense_index + 1} of "{word}": "{basic_definition}"{synonyms_context}{antonyms_context}

Provide:
{synonyms_instruction}
{antonyms_instruction}
{phrases_instruction}

Focus on the most useful words/phrases that help learners expand vocabulary.

Output must be valid JSON matching the SenseRelatedWords schema."""


def get_common_phrases_prompt(word: str) -> str:
    """Generate prompt for common phrases and collocations"""
    return f"""You are a linguistic expert specializing in common English phrases and collocations.

For the word "{word}", identify 1-3 commonly used phrases or collocations that CONTAIN this word.

CRITICAL REQUIREMENT: Every phrase MUST actually include the word "{word}" as part of the phrase.

Examples of what to include:
- For "run": "run out of", "in the long run", "run up a bill"
- For "pipe": "pipe down", "pipe dream", "put that in your pipe and smoke it"

Examples of what to AVOID:
- For "pipe": "smoke like a chimney" (does not contain "pipe")
- For "run": "jogging" (does not contain "run")

Consider:
- If the word is typically used alone (e.g., "hello", "cat"), return just the word
- If the word commonly appears in phrases (e.g., "run out of", "in the long run", "kick the bucket"), return those phrases
- Focus on the most frequent, natural combinations that actually contain the target word
- Include phrasal verbs, idioms, and common expressions that include the word

Return exactly 1-3 phrases where each phrase contains the word "{word}". If the word is standalone, return just the word.

Output must be valid JSON matching the CommonPhrases schema."""


def get_sense_usage_notes_prompt(word: str, sense_index: int, basic_definition: str) -> str:
    """Generate prompt for usage notes and guidance (Agent 4) - parallel execution"""
    return f"""You are a linguistic expert specializing in usage guidance for language learners.

Analyze sense #{sense_index + 1} of "{word}": "{basic_definition}"

Provide:
1. **usage_notes**: Critical guidance on when/how to use this sense and common pitfalls for learners (2-3 sentences)

Focus on practical advice that helps learners avoid mistakes.

Output must be valid JSON matching the SenseUsageNotes schema."""